/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * Jump2DConstraintJacobianFinalSP.cpp
 *
 * Code generation for function 'Jump2DConstraintJacobianFinalSP'
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "Jump2DBounds.h"
#include "Jump2DConstraintJacobian.h"
#include "Jump2DConstraintJacobianFinal.h"
#include "Jump2DConstraintJacobianFinalSP.h"
#include "Jump2DConstraintJacobianInitial.h"
#include "Jump2DConstraintJacobianInitialSP.h"
#include "Jump2DConstraintJacobianSP.h"
#include "Jump2DConstraints.h"
#include "Jump2DConstraintsFinal.h"
#include "Jump2DConstraintsInitial.h"
#include "Jump2DCost.h"
#include "Jump2DCostGradient.h"
#include "Jump2DInitialize.h"
#include "Jump2DLagrangianHessian.h"
#include "Jump2DLagrangianHessianFinal.h"
#include "Jump2DLagrangianHessianFinalSP.h"
#include "Jump2DLagrangianHessianInitial.h"
#include "Jump2DLagrangianHessianInitialSP.h"
#include "Jump2DLagrangianHessianSP.h"

/* Function Definitions */
void Jump2DConstraintJacobianFinalSP(double iter, double NUM_X, double NUM_C,
  double row_index_final_CJ[26], double col_index_final_CJ[26])
{
  double t2;

  /* JUMP2DCONSTRAINTJACOBIANFINALSP */
  /*     [ROW_INDEX_FINAL_CJ,COL_INDEX_FINAL_CJ] = JUMP2DCONSTRAINTJACOBIANFINALSP(ITER,NUM_X,NUM_C) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     27-Aug-2019 12:38:33 */
  t2 = NUM_C * iter;
  row_index_final_CJ[0] = t2;
  row_index_final_CJ[1] = t2 + 1.0;
  row_index_final_CJ[2] = t2 + 2.0;
  row_index_final_CJ[3] = t2 + 3.0;
  row_index_final_CJ[4] = t2 + 4.0;
  row_index_final_CJ[5] = t2 + 5.0;
  row_index_final_CJ[6] = t2;
  row_index_final_CJ[7] = t2 + 2.0;
  row_index_final_CJ[8] = t2 + 3.0;
  row_index_final_CJ[9] = t2 + 5.0;
  row_index_final_CJ[10] = t2 + 1.0;
  row_index_final_CJ[11] = t2 + 2.0;
  row_index_final_CJ[12] = t2 + 4.0;
  row_index_final_CJ[13] = t2 + 5.0;
  row_index_final_CJ[14] = t2 + 6.0;
  row_index_final_CJ[15] = t2 + 7.0;
  row_index_final_CJ[16] = t2;
  row_index_final_CJ[17] = t2 + 2.0;
  row_index_final_CJ[18] = t2 + 3.0;
  row_index_final_CJ[19] = t2 + 5.0;
  row_index_final_CJ[20] = t2 + 1.0;
  row_index_final_CJ[21] = t2 + 2.0;
  row_index_final_CJ[22] = t2 + 4.0;
  row_index_final_CJ[23] = t2 + 5.0;
  row_index_final_CJ[24] = t2 + 8.0;
  row_index_final_CJ[25] = t2 + 9.0;
  t2 = NUM_X * iter;
  col_index_final_CJ[0] = t2;
  col_index_final_CJ[1] = t2 + 1.0;
  col_index_final_CJ[2] = t2 + 2.0;
  col_index_final_CJ[3] = t2 + 3.0;
  col_index_final_CJ[4] = t2 + 4.0;
  col_index_final_CJ[5] = t2 + 5.0;
  col_index_final_CJ[6] = t2 + 6.0;
  col_index_final_CJ[7] = t2 + 6.0;
  col_index_final_CJ[8] = t2 + 6.0;
  col_index_final_CJ[9] = t2 + 6.0;
  col_index_final_CJ[10] = t2 + 7.0;
  col_index_final_CJ[11] = t2 + 7.0;
  col_index_final_CJ[12] = t2 + 7.0;
  col_index_final_CJ[13] = t2 + 7.0;
  col_index_final_CJ[14] = t2 + 7.0;
  col_index_final_CJ[15] = t2 + 7.0;
  col_index_final_CJ[16] = t2 + 8.0;
  col_index_final_CJ[17] = t2 + 8.0;
  col_index_final_CJ[18] = t2 + 8.0;
  col_index_final_CJ[19] = t2 + 8.0;
  col_index_final_CJ[20] = t2 + 9.0;
  col_index_final_CJ[21] = t2 + 9.0;
  col_index_final_CJ[22] = t2 + 9.0;
  col_index_final_CJ[23] = t2 + 9.0;
  col_index_final_CJ[24] = t2 + 9.0;
  col_index_final_CJ[25] = t2 + 9.0;
}

/* End of code generation (Jump2DConstraintJacobianFinalSP.cpp) */
