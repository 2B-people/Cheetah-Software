#ifndef MINI_CHEETAH_GRAPHICS_H
#define MINI_CHEETAH_GRAPHICS_H

#include <QMatrix4x4>
#include <iostream>
#include "obj_loader.h"
#include "simulator_interface.h"



// generates graphics data for the mini-cheetah robot
class mini_cheetah_graphics
{
public:
    // the constructor does not perform the (possibly) time consuming model loading
    mini_cheetah_graphics(int use_cheetah_3);
    ~mini_cheetah_graphics();
    // load models from OBJ file

    // update transforms based on robot configuration
    void update();
    // return the number of items to render
    int number_of_models();
    // gets the transformation matrix for an item to render
    // because there are millions of points to transform, this math is done on the GPU
    QMatrix4x4 get_model_xform(int model);
    // number of face in an item
    int get_number_of_faces(int model);
    // vertices of an item, given in x,y,z triplets for triangular faces
    float* get_vertices(int model);
    // normals at the corners of each face, same xyz triplets for triangular faces
    float* get_normals(int model);
    // colors at the corners of each face, same xyz triples for triangular faces
    float* get_colors(int model);
    // update the state of the displayed robot
    void set_robot_state(CheetahState* state);

private:
    void load_models(int use_cheetah_3);
    // method to set a uniform color
    void fill_with_boring_color(float* data, int size, float r, float g, float b);

    // method to color a checkerboard model generated by the checkerboard tool (see utility scripts folder)
    void fill_checkerboard_colors(float* data, int size);

    // loaders to load model data from file for the bodies
    ObjLoader u_link_loader;
    ObjLoader l_link_loader;
    ObjLoader body_loader;
    ObjLoader ground_loader;
    ObjLoader abad_loader;

    // number of vertices in each body
    int u_link_vert_count = 0;
    int l_link_vert_count = 0;
    int ground_vert_count;
    int body_vert_count;
    int abad_vert_count;

    // vertices/normals/color arrays
    float* u_link_vertices;
    float* l_link_vertices;
    float* body_vertices;
    float* ground_vertices;
    float* abad_vertices;

    float* u_link_normals;
    float* l_link_normals;
    float* ground_normals;
    float* body_normals;
    float* abad_normals;

    float* u_link_colors;
    float* l_link_colors;
    float* body_colors;
    float* ground_colors;
    float* abad_colors;

    // unused
    QMatrix4x4 model_matrices[10];
    // body to where the hip motor connects
    QMatrix4x4 body_to_abad[4];
    // position of body in the world
    QMatrix4x4 body_xform;
    // the offset transforms rotate/translate the bodies into a reasonable configuration
    // most of them were exported with the wrong coordinate system
    QMatrix4x4 link_1_offset;
    QMatrix4x4 link_2_offset_p;
    QMatrix4x4 link_2_offset_n;
    QMatrix4x4 link_0_offset_p;
    QMatrix4x4 link_0_offset_n;
    QMatrix4x4 link_0_offset_bp;
    QMatrix4x4 link_0_offset_bn;
    QMatrix4x4 body_offset;

    // transformation for parent-child when joint is at q = 0
    QMatrix4x4 l1_xform;
    QMatrix4x4 l0_xform_p;
    QMatrix4x4 l0_xform_n;

    // joint transformations
    QMatrix4x4 r_abad[4];
    QMatrix4x4 r_hip[4];
    QMatrix4x4 r_knee[4];

    // identity
    QMatrix4x4 eye;

    // ground scroll
    QMatrix4x4 ground_scroll;

    double ground_x_scroll = 0.f;
    double ground_y_scroll = 0.f;

    // frame count
    int fc = 0;

    CheetahState cs;

    bool using_cheetah_3 = false;

};

#endif // MINI_CHEETAH_GRAPHICS_H
